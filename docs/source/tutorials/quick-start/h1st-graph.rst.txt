H1st Graph
##########

An H1st Graph object encapsulates an execution flow chart that allows Models and Actions to be smoothly tied together. This structure enables both ML and Human-knowledge models to be incorporated into a seemless data processing and inference pipeline.

This is an example of a very simple graph which prints hello for each even number x in the input stream, using a conditional RuleBasedModel. The rule-based models extends the h1st Model class implying that it processes the incoming data to produce some prediction, transformation or analysis on that data. The HelloPrinter class extends the h1st Action class implying that it performs a simple action in response to some input.


.. code-block:: python

  from h1st.model.model import Model
  from h1st.h1flow.h1flow import Action, Graph
  from h1st.h1flow.h1step import Action, Descision ## Why is Action ins h1step and h1flow?

  class RuleBasedModel(Model):
      """
      Simple rule-based model that "predicts" if a given value is an even number
      """
      def process(self, input_data: dict) -> dict:
          predictions = [{'prediction': x % 2 == 0, 'value': x} for x in input_data["values"]]
          return {"predictions": predictions}

  class HelloPrinter(Action):
      """Print hello to the inputs value"""
      def call(self, command, inputs):
          # Note that H1st does the conditional/filtering orchestration already.
          # All we need to do here is just to print.
          for d in inputs["predictions"]:
              print("Hello world {}!".format(d["value"]))


The H1st graph itself is created by adding nodes incrementally.

.. code-block:: python

  from h1st.h1flow.h1flow import Graph
  from h1st.h1flow.h1step import Action, Decision, NoOp

  g = Graph()
  g.start()
  g.add(h1.Decision(RuleBasedModel(), result_field="predictions"))
  g.add(yes=HelloPrinter(), no=NoOp())
  g.end()

  results = g.predict({"values": range(6)})

Note that the first branch is an h1st Decision which redirects the data flow into the later yes and no nodes based on the RuleBasedModelâ€™s predictions.

In terms of data flow, the input to the Graph predict method is passed to the RuleBasedModel's process function which in turn produces a dict. The Decision object forwards a dict containing the result_field "predictions" to the HelloPrinter's call function if the Decision is True and does nothing if the decision is false. In this way, the Graph simplifies the construction of complex action and information relay flows.

H1st Graphs, by default, operate in batch mode; meaning that H1st Decisions looks at {"predictions": [{"prediciton": True, ...}, {"prediction": False, }]} and redirect True/False decision points to the to the right yes/no branch as a list.

# TODO: Fix this last statement, this means that Decision is being told to look at the "predictions" field but has no reference to the "prediction" field. It also means that the output of the Model class must operate in batch-mode and return a dict with a field that has a list of dicts with "prediction" fields. This is way too complicated and makes very little sense. It also deviates from a lot more inutitive schema already implemented elsewhere. Instead the model "process" or "predict" method should operate on a single data point and return a dict with a result_field. The Graph should run each data point through that process function and compile a list of Decisions by extracting that result_field and then proceed through the rest of the graph.  

.. code-block::

  Hello world 0!
  Hello world 2!
  Hello world 4!
